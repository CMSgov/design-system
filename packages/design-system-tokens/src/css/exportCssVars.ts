import path from 'path';
import fs from 'fs';
import { FileDescriptor } from '../lib/types';
import { flattenTokens, writeFile } from '../lib/file';
import { FlattenedTokens, FlattenedTokensByFile, readTokenFiles, Token } from '../lib/tokens';

/**
 * Some Sass variables are required to accomplish Sassy things like loops,
 * mixins and media queries. These variables cannot currently be mapped to
 * CSS custom properties without causing Sass or syntax errors.
 *
 * This list includes the variable names to be created for Sass implementation.
 * This list doesn't exclude these variables from being exported as CSS
 * custom properties.
 *
 * These values will have a direct sass variable -> value definition.
 */
const sassVariableList: string[] = [
  'grid-columns',
  'media-width-xs',
  'media-width-sm',
  'media-width-md',
  'media-width-lg',
  'media-width-xl',
  'spacer-1',
  'spacer-2',
  'spacer-3',
  'spacer-4',
  'spacer-5',
  'spacer-6',
  'spacer-7',
  'spacer-none',
  'spacer-half',
];

/**
 * Formats an object containing key/value token pairs as a single string containing
 * the formatted values ready to be written to a SCSS file, including line breaks
 *
 * @param items - The object containing the key/value pairs
 * @param prefix - The prefix to be appended to each key on export
 * @param formatter - A function which takes a key, value and returns a formatted key, value string
 * @param separator - The separator between the prefix and key
 * @returns A string which contains all formatted key/value pairs
 */
const formatTokensAsCssVars = (
  items: Record<string, any>,
  prefix: string,
  formatter: (name: string, value: string) => string,
  separator: string
): string => {
  let SCSS = '';
  Object.entries(items).forEach(([name, value]) => {
    // global objects in themes are not prefixed by the token type
    name = prefix === 'global' ? name : `${prefix}${separator}${name}`;
    SCSS += formatter(name, value);
  });
  return SCSS;
};

/**
 * Writes an SCSS file that maps a SCSS variable to token value
 *
 * @param filename - name of file to be created
 * @param file -  a single FileDescriptor item generated by getFileDescriptors
 * @param importedModule - module data
 * @param sep - separator string between prefix and key
 */
const writeSassLayout = (
  filename: string,
  file: FileDescriptor,
  importedModule: any,
  sep: string
) => {
  let tokenItems: Record<string, any>;
  let output = '';

  Object.entries(importedModule.default).forEach(([section]) => {
    tokenItems = flattenTokens(importedModule.default[section]);
    // core requires !default for each style
    const defaultInclude = file.baseName.includes('core') ? ' !default' : '';

    output += formatTokensAsCssVars(
      tokenItems,
      section,
      (name, value) => {
        if (sassVariableList.includes(name)) {
          return `$${name}: ${value}${defaultInclude};\n`;
        }
        return '';
      },
      sep
    );
  });

  if (output.length > 0) {
    writeFile(filename, output);
  }
};

/**
 * Maps a css variable to its value
 *
 * @param file -  a single FileDescriptor item generated by getFileDescriptors
 * @param importedModule - module data
 * @param sep - separator string between prefix and key
 */
const mapCssVariablesToValues = (importedModule: any, sep: string) => {
  let tokenItems: Record<string, any>;
  let output = '';

  Object.entries(importedModule.default).forEach(([section]) => {
    tokenItems = flattenTokens(importedModule.default[section]);

    output += formatTokensAsCssVars(
      tokenItems,
      section,
      (name, value) => {
        return `--${name}: ${value};\n`;
      },
      sep
    );
  });

  return output;
};

/**
 * Accepts an array of file descriptors generated by getFileDescriptors('path')
 * and writes their imported data to filesystem as Sass (layout) & CSS files
 *
 * @param fileDescriptors - An array of fileDescriptors generated by getFileDescriptors
 * @param outPath - The output path for the files
 * @returns An exit code based on success writing output
 */
export const exportCssVars = (fileDescriptors: FileDescriptor[], outPath: string): number => {
  if (!fs.existsSync(outPath)) {
    fs.mkdirSync(outPath, { recursive: true });
  }

  const groupByTheme = fileDescriptors.reduce((acc: Record<string, any[]>, file) => {
    const theme = file.baseName.split('-')[0];
    if (!acc[theme]) {
      acc[theme] = [];
    }
    acc[theme].push(file);
    return acc;
  }, {});

  Object.entries(groupByTheme).forEach(([theme, files]) => {
    let output = '';

    files.forEach((file) => {
      const importedModule = require(`${file.moduleImportName}`);
      // Component files do not need a separator
      let sep = '';

      // SCSS files are only generated from global token files
      if (!file.baseName.includes('component')) {
        // Global token files need a separator
        sep = '-';

        const sassFilename = `${outPath}/${theme}-layout-tokens.scss`;
        writeSassLayout(sassFilename, file, importedModule, sep);
      }

      output += mapCssVariablesToValues(importedModule, sep);
    });

    const cssVarFilename = `${outPath}/${theme}-theme.css`;
    writeFile(cssVarFilename, ':root, ::before, ::after, ::backdrop {\n' + output + '}');
  });

  return 0;
};

function isAlias(value: string) {
  return value.toString().trim().charAt(0) === '{';
}

function resolveTokenValue(
  token: Token,
  themeTokens: FlattenedTokens,
  systemTokens: FlattenedTokens
): string {
  if (typeof token.$value === 'string' && isAlias(token.$value)) {
    // Assume aliases are in the format {group.subgroup.token} with any number of optional groups/subgroups
    const aliasedTokenName = token.$value.trim().replace(/[{}]/g, '');

    // Token aliases are assumed to be unique
    const aliasedToken = themeTokens[aliasedTokenName] ?? systemTokens[aliasedTokenName];
    if (!aliasedToken) {
      throw new Error(`No token found for alias {${aliasedTokenName}}`);
    }

    // TODO: After we've merged a version of this that has been verified to be 1-1 with
    // the previous script, we could use `var(--some-other-token)` instead of always
    // resolving all the way down to the literal value.
    return resolveTokenValue(aliasedToken, themeTokens, systemTokens);
  } else {
    // TODO: Actually try to convert the value into an appropriate string base on the $type
    return JSON.stringify(token.$value);
  }
}

export function generateCssVarsFromTokens(
  themeTokens: FlattenedTokens,
  systemTokens: FlattenedTokens
): string {
  const vars = Object.entries(themeTokens).map(([key, token]) => {
    const varName = key.replace(/\./g, '-'); // TODO: It's actually a mix of - and __
    const varValue = resolveTokenValue(token, themeTokens, systemTokens);
    return `--${varName}: ${varValue};`;
  });
  return vars.join('\n');
}

export function tokenFilesToCssFiles(tokensByFile: FlattenedTokensByFile): {
  [fileName: string]: string;
} {
  const systemTokens = tokensByFile['System.Value.json'];
  if (!systemTokens) {
    throw new Error('Could not find entry for system tokens');
  }

  return Object.keys(tokensByFile)
    .filter((fileName) => fileName.startsWith('Theme.'))
    .reduce((obj, fileName) => {
      const themeName = fileName.split('.')[1];
      const themeTokens = tokensByFile[fileName];
      const cssVars = generateCssVarsFromTokens(themeTokens, systemTokens);
      const cssFileContents = `:root, ::before, ::after, ::backdrop {\n${cssVars}\n}`;
      const cssFileName = `${themeName}-theme.css`;
      obj[cssFileName] = cssFileContents;
      return obj;
    }, {});
}

export async function writeCssVars(tokensDir: string, outputDir: string): Promise<string[]> {
  const tokensByFile = readTokenFiles(tokensDir);
  const cssFiles = tokenFilesToCssFiles(tokensByFile);

  // Write the files for each theme concurrently
  const filesWritten = await Promise.all(
    Object.keys(cssFiles).map(async (fileName) => {
      const contents = cssFiles[fileName];
      const fullPath = path.join(outputDir, fileName);
      await fs.promises.writeFile(fullPath, contents);
      return fullPath;
    })
  );

  return filesWritten;
}

export default exportCssVars;
