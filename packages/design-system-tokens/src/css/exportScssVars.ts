import { FileDescriptor } from '../lib/types';
import { FlattenedTokens, FlattenedTokensByFile } from '../lib/tokens';
import { OutputFiles } from './writeFiles';
import { flattenTokens, writeFile } from '../lib/file';

/**
 * Some Sass variables are required to accomplish Sassy things like loops,
 * mixins and media queries. These variables cannot currently be mapped to
 * CSS custom properties without causing Sass or syntax errors.
 *
 * This list includes the variable names to be created for Sass implementation.
 * This list doesn't exclude these variables from being exported as CSS
 * custom properties.
 *
 * These values will have a direct sass variable -> value definition.
 */
const layoutTokenNames: string[] = [
  'grid.columns',
  'media.width-xs',
  'media.width-sm',
  'media.width-md',
  'media.width-lg',
  'media.width-xl',
  'spacer.1',
  'spacer.2',
  'spacer.3',
  'spacer.4',
  'spacer.5',
  'spacer.6',
  'spacer.7',
  'spacer.none',
  'spacer.half',
];

/**
 * Writes an SCSS file that contains token variables
 *
 * @param filename - name of file to be created
 * @param file -  a single FileDescriptor item generated by getFileDescriptors
 * @param importedModule - module data
 * @param sep - separator string between prefix and key
 */
const writeSassFile = (
  filename: string,
  file: FileDescriptor,
  importedModule: any,
  sep: string
) => {
  let tokenItems: Record<string, any>;
  let output = '';

  Object.entries(importedModule.default).forEach(([section]) => {
    tokenItems = flattenTokens(importedModule.default[section]);
    // core needs !default everywhere
    const defaultInclude = file.baseName.includes('core') ? ' !default' : '';

    Object.entries(tokenItems).forEach(([name, value]) => {
      // global objects in themes are not prefixed by the token type
      name = section === 'global' ? name : `${section}${sep}${name}`;
      output += `$${name}: ${value}${defaultInclude};\n`;
    });
  });

  if (output.length > 0) {
    writeFile(filename, output);
  }
};

export function generateScssVarsFromTokens(
  themeTokens: FlattenedTokens,
  systemTokens: FlattenedTokens
): string {
  // const vars = Object.entries(themeTokens).map(([key, token]) => {
  //   const varName = key.replace(/\./g, '-'); // TODO: It's actually a mix of - and __
  //   const varValue = resolveTokenValue(token, themeTokens, systemTokens);
  //   return `--${varName}: ${varValue};`;
  // });
  // return vars.join('\n');
}

export function tokenFilesToScssFiles(tokensByFile: FlattenedTokensByFile): OutputFiles {
  const systemTokens = tokensByFile['System.Value.json'];
  if (!systemTokens) {
    throw new Error('Could not find entry for system tokens');
  }

  return Object.keys(tokensByFile)
    .filter((fileName) => fileName.startsWith('Theme.'))
    .reduce((obj, fileName) => {
      const themeName = fileName.split('.')[1];
      const themeTokens = tokensByFile[fileName];
      const scssVars = generateScssVarsFromTokens(themeTokens, systemTokens);
      const scssFileName = `${themeName}-theme.scss`;
      obj[scssFileName] = scssVars;
      return obj;
    }, {});
}

export function tokenFilesToScssLayoutFiles(tokensByFile: FlattenedTokensByFile): OutputFiles {
  const systemTokens = tokensByFile['System.Value.json'];
  const filteredTokens = Object.fromEntries(
    Object.entries(systemTokens).filter(([name]) => layoutTokenNames.includes(name))
  );
  return {
    'layout.scss': generateScssVarsFromTokens(filteredTokens, filteredTokens),
  };
}
